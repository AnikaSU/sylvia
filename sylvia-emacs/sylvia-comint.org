#+TITLE: Sylvia Comint
#+AUTHOR: Brandon Guttersohn

Interacting with a Sylvia instance through Emacs using comint. Based
on tutorial listed in the references section.

* Parameters

#+BEGIN_SRC emacs-lisp
(defvar sylvia:python2-program "python2"
   "Path to Python2 binary.")

(defvar sylvia:module-path nil
  "Path to Sylvia python module, if not already in PYTHONPATH.")

(defvar sylvia:python2-arguments '("-m" "sylvia")
  "Arguments to Python2")

(defvar sylvia:prompt-regexp ".*> "
  "Prompt for Sylvia.")
#+END_SRC

#+RESULTS:
: sylvia:prompt-regexp

* Running Sylvia

#+BEGIN_SRC emacs-lisp
  (defun sylvia:run ()
    "Run an inferior instance of Sylvia."
    (interactive)
    (let*
        ((buffer (comint-check-proc "*sylvia*")))
      ;; Switch to buffer if it exists
      (pop-to-buffer-same-window
       (if (or buffer (not (derived-mode-p 'sylvia-repl-mode))
               (comint-check-proc (current-buffer)))
           (get-buffer-create (or buffer "*Sylvia*"))
         (current-buffer)))
      ;; create the comint process otherwise
      (unless buffer
        (apply 'make-comint-in-buffer "Sylvia" nil
               sylvia:python2-program nil sylvia:python2-arguments)
        (sylvia-repl-mode))))
#+END_SRC

#+RESULTS:
: sylvia:run

* Sylvia REPL Mode

#+BEGIN_SRC emacs-lisp
(defun sylvia--initialize ()
  "Helper function to initialize Sylvia"
  (setq comint-process-echoes t)
  (setq comint-use-prompt-regexp t))

(define-derived-mode sylvia-repl-mode comint-mode "Sylvia"
  "Major mode for `sylvia:run'.

\\<sylvia-mode-map>"
  nil "Sylvia"
  ;; this sets up the prompt so it matches things like: [foo@bar]
  (setq comint-prompt-regexp sylvia:prompt-regexp)
  ;; this makes it read only; a contentious subject as some prefer the
  ;; buffer to be overwritable.
  (setq comint-prompt-read-only t)
  ;; this makes it so commands like M-{ and M-} work.
  (set (make-local-variable 'paragraph-separate) "\\'")
  ;(set (make-local-variable 'font-lock-defaults) '(sylvia-font-lock-keywords t))
  (set (make-local-variable 'paragraph-start) sylvia:prompt-regexp))

;; this has to be done in a hook. grumble grumble.
(add-hook 'sylvia-mode-hook 'sylvia--initialize)
#+END_SRC

#+RESULTS:
| sylvia--initialize |

* Basic APIs

** Wrappers

#+BEGIN_SRC emacs-lisp
(defun sylvia:synchronous-repl-command (command)
    "Sycnhronously send a command to the *Sylvia* buffer and return output string
Optionally split string into a list.
Modified from: https://stackoverflow.com/questions/46631920/silently-send-command-to-comint-without-printing-prompt"
  (let ((output-buffer "*Sylvia-Output*")
        (process       (get-process "Sylvia"))
        (inhibit-quit  nil))
    (with-current-buffer (get-buffer-create output-buffer)
      (erase-buffer)
      (comint-redirect-send-command-to-process command output-buffer "*Sylvia*" nil t)
      ;; Wait for the process to complete
      (set-buffer (process-buffer process))
      (while (and (null comint-redirect-completed)
                  (accept-process-output process)))
      ;; Collect the output
      (set-buffer output-buffer)
      (goto-char (point-min))
      ;; Skip past the command, if it was echoed
      (and (looking-at command)
           (forward-line))
      ;; Grab the rest of the buffer
      (buffer-substring-no-properties (point) (- (point-max) 1)))))
#+END_SRC

#+RESULTS:
: sylvia:synchronous-repl-command

#+BEGIN_SRC emacs-lisp
(defun sylvia:split-results (result-str &optional split-rows)
  "Split results from sylvia. Returns each line as a list. Optionally splits each line on whitespace"
  (let
      ((lines (split-string result-str "\n")))
    (remove-if 'seq-empty-p
      (if split-rows
          (mapcar (lambda (x) (remove-if 'seq-empty-p (split-string x))) lines)
        lines))))
#+END_SRC

#+RESULTS:
: sylvia:split-results

** Commands

#+BEGIN_SRC emacs-lisp
(defun sylvia:lookup (word)
    "Lookup the phonemes for a word"
    (sylvia:split-results (sylvia:synchronous-repl-command (concat "lookup " word)) t))
#+END_SRC

#+RESULTS:
: sylvia:lookup

#+BEGIN_SRC emacs-lisp
(defun sylvia:infer (word)
    "Infer the phonemes for a word"
    (sylvia:split-results (sylvia:synchronous-repl-command (concat "infer " word)) t))
#+END_SRC

#+RESULTS:
: sylvia:infer

#+BEGIN_SRC emacs-lisp
(defun sylvia:rhyme (word &optional level)
    "Find rhymes for word. Optionally set rhyme level ('default, 'perfect, or 'loose)."
    (let
        ((rhyme-level (if level (concat (symbol-name level) " ") "")))
      (sylvia:split-results (sylvia:synchronous-repl-command (concat "rhyme " rhyme-level word)))))
#+END_SRC

#+RESULTS:
: sylvia:rhyme

** Buffer Operations

#+BEGIN_SRC emacs-lisp
(defun sylvia:compose-buffer (buffer-name)
    "Send buffer's contents to Sylvia as a composed poem."
    (with-current-buffer (get-buffer buffer-name)
      (let
        ((cmd (concat "compose " buffer-name
                "\n"
                (buffer-string)
                "\n")))
      (sylvia:synchronous-repl-command cmd)
      (process-send-eof "Sylvia"))))
#+END_SRC

#+RESULTS:
: Sylvia

#+BEGIN_SRC emacs-lisp
(defun sylvia:euphony (buffer-name)
    "Get phonaesthetic map for current composed version of buffer."
    (sylvia:synchronous-repl-command (concat "euphony " buffer-name)))
#+END_SRC

#+RESULTS:
: sylvia:euphony

* Tests
:PROPERTIES:
:header-args: :tangle no
:END:

** Lookup

#+BEGIN_SRC emacs-lisp
(sylvia:lookup "cats")
#+END_SRC

#+RESULTS:
| K | AE | T | S |

#+BEGIN_SRC emacs-lisp
(sylvia:lookup "CaTs")
#+END_SRC

#+RESULTS:
| K | AE | T | S |

#+BEGIN_SRC emacs-lisp
(sylvia:lookup "tomato")
#+END_SRC

#+RESULTS:
| T | AH | M | EY | T | OW |
| T | AH | M | AA | T | OW |

#+BEGIN_SRC emacs-lisp
(length (sylvia:lookup "babaloo"))
#+END_SRC

#+RESULTS:
: 0


** Rhyme

#+BEGIN_SRC emacs-lisp
(sylvia:rhyme "saturday")
#+END_SRC

#+RESULTS:
| Saturdays | Dastardly | Saturday's |

#+BEGIN_SRC emacs-lisp
(sylvia:rhyme "saturday" 'perfect)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(sylvia:rhyme "Ivanhoe" 'loose)
#+END_SRC

#+RESULTS:
| Idaho | Diagnosis | Microphone | Diagnosed | Microscope | Diagnose | Diagnosing | Isotope | Diagnoses | Microscopes | Isotopes | Cuyahoga | Dynamo | Kaleidoscope | Zydeco | Piezoelectric | Ayatollah | Styrofoam | Xylophone | Gyroscope | Amyotrophic | Byelorussia | Dialtone | Gyroscopes | Iacocca | Dinotopia | Iacono | Titleholder | Diantonio | Virazole | Ayatollah's | Iacocca's | Iacona | Cyclostome | Cyclostomes | Icenogle | Diaphonia | Stereomicroscope | Kayapo | Idaho's | Ivaco | Isentrope | Idaho-falls |

** Compose

#+BEGIN_SRC emacs-lisp
(sylvia:compose-buffer "testpoem")
#+END_SRC

#+RESULTS:
: Sylvia

** Euphony

#+BEGIN_SRC emacs-lisp
(sylvia:euphony "testpoem")
#+END_SRC

#+RESULTS:
: 
: ~~~~~ ~~ ~~X
: biolets ~~ X~~
: 

* References

[[https://www.masteringemacs.org/article/comint-writing-command-interpreter][Basic tutorial on comint derived major modes.]]
